<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">

    <!-- iPhoneã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼å•é¡Œå¯¾ç­–ï¼ˆè¡¨ç¤ºé ˜åŸŸã‚’ãªã‚‹ã¹ãç¢ºä¿ï¼‰ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <!-- ãƒ›ãƒ¼ãƒ ç”»é¢è¿½åŠ æ™‚ï¼ˆiOSï¼‰ã§â€œ2â€ã«ãªã‚‹å•é¡Œã®å¯¾ç­–ï¼šã‚¢ã‚¤ã‚³ãƒ³æŒ‡å®š -->
    <!-- â€»åŒéšå±¤ or ãƒ«ãƒ¼ãƒˆã« icon-180.pngï¼ˆ180x180 PNGï¼‰ã‚’ç½®ã„ã¦ãã ã•ã„ -->
    <link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icon-167.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
    <link rel="apple-touch-icon" sizes="120x120" href="icon-120.png">
    <meta name="apple-mobile-web-app-title" content="HORSE RACE">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- ã¤ã„ã§ã«é€šå¸¸ã®faviconã‚‚ï¼ˆä»»æ„ï¼‰ -->
    <link rel="icon" href="/favicon.ico">

    <title>2026 HAPPY HORSE RACE (v8 Final + Back + Fullscreen)</title>

    <style>
        /* --- CSS ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾© --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #fff;
            font-family: 'Verdana', sans-serif;
            overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
            touch-action: none; /* ã‚¹ãƒãƒ›ã§ã®ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç­‰ã‚’ç„¡åŠ¹åŒ– */
            user-select: none;
            -webkit-user-select: none;

            /* é«˜ã•ã¯ dvh ã‚’å„ªå…ˆï¼ˆiOSã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼ã§å´©ã‚Œã«ãã„ï¼‰ */
            width: 100vw;
            height: 100vh;
            height: 100dvh;

            display: flex;
            justify-content: center;
            align-items: center;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            box-sizing: border-box;
        }

        #game-wrapper {
            position: relative;
            width: 800px;  /* åŸºæº–ã‚µã‚¤ã‚º */
            height: 450px; /* åŸºæº–ã‚µã‚¤ã‚º */
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            overflow: hidden;
            transform-origin: center center;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UIã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆå…±é€šï¼‰ */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Canvasã¸ã®ã‚¯ãƒªãƒƒã‚¯ã‚’é€é */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: rgba(0,0,0,0.4);
            z-index: 10;
        }

        /* ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªUIè¦ç´ ã¯pointer-eventsã‚’æœ‰åŠ¹åŒ– */
        .ui-content {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 4px solid #333;
            color: #333;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* â˜… ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè¡¨ç¤ºï¼ˆè¿½åŠ ï¼‰ */
        .credit{
            margin-top: 14px;
            font-size: 0.7rem;
            color: #888;
            letter-spacing: 0.08em;
            font-family: 'Verdana', sans-serif;
            opacity: 0.75;
            transition: opacity 0.2s;
            user-select: text; /* ã‚³ãƒ”ãƒ¼ã§ãã¦ã‚‚é‚ªé­”ã«ãªã‚‰ãªã„ã®ã§ON */
        }
        .credit:hover{
            opacity: 1;
        }

        /* å‹•ç”»ç”»é¢ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #screen-bonus-video {
            background-color: #000; /* èƒŒæ™¯ã‚’é»’ã« */
            z-index: 20; /* æœ€å‰é¢ã« */
        }
        #screen-bonus-video .ui-content {
            background: transparent;
            border: none;
            box-shadow: none;
            color: #fff;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #bonus-video {
            width: 80%;
            max-height: 70%;
            border: 2px solid gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            background: #000;
            margin-bottom: 20px;
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        h1 { margin: 0 0 10px 0; color: #d32f2f; font-size: 1.8rem; }
        h2 { margin: 10px 0; font-size: 1.4rem; }
        p { margin: 10px 0; line-height: 1.5; font-size: 0.9rem;}

        button {
            background: #ff9800;
            border: none;
            border-bottom: 4px solid #e65100;
            color: white;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.1s;
            touch-action: manipulation; /* ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ é˜²æ­¢ */
        }
        button:active {
            transform: translateY(4px);
            border-bottom: none;
            margin-bottom: 9px; /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå´©ã‚Œé˜²æ­¢ */
        }
        button.secondary { background: #4caf50; border-bottom-color: #1b5e20; }
        button.danger { background: #f44336; border-bottom-color: #b71c1c; }

        button.golden {
            background: linear-gradient(to bottom, #ffd700, #ffb300);
            border-bottom-color: #b8860b;
            color: #000;
            text-shadow: 0 1px 0 rgba(255,255,255,0.5);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºç”»é¢ç”¨ */
        .parts-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .part-group { text-align: center; }
        .part-group button { padding: 5px 10px; font-size: 0.8rem; }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10åˆ— */
            gap: 5px;
            margin: 10px auto;
            max-width: 350px;
        }
        .color-btn {
            width: 25px;
            height: 25px;
            border: 2px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            touch-action: manipulation;
        }
        .color-btn.selected { border: 3px solid #000; transform: scale(1.2); z-index: 10;}

        /* éš ã—ãƒœã‚¿ãƒ³ç”¨ */
        .color-btn.secret {
            background-color: transparent !important;
            border: 2px solid transparent;
            box-shadow: none;
        }
        .color-btn.secret.selected {
            border: 3px solid #d32f2f; /* é¸æŠæ™‚ã¯èµ¤æ ã§è¦‹ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ */
        }

        #preview-canvas {
            border: 4px solid #333; /* æ ç·šã‚’å¼·èª¿ */
            margin: 5px auto;
            background: #fff;
            border-radius: 10px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }

        /* ã‚²ãƒ¼ãƒ å†…UIï¼ˆã‚¿ãƒƒãƒãƒœã‚¿ãƒ³ç­‰ï¼‰ */
        #game-ui {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: auto;
            height: auto;
            pointer-events: auto;
            z-index: 5;
        }
        .touch-controls {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            align-items: flex-end;
        }
        .touch-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 2px solid #fff;
            color: #fff;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            user-select: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);

            /* é€£æ‰“å¯¾ç­– */
            touch-action: none !important;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        .touch-btn:active, .touch-btn.active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.6);
        }
        #btn-dash { background: rgba(255, 165, 0, 0.5); }
        #btn-fire { background: rgba(220, 20, 60, 0.6); display: none; width: 60px; height: 60px; font-size: 0.8rem; }
        #btn-jump { background: rgba(30, 144, 255, 0.5); width: 80px; height: 80px; font-size: 1rem; }

        .hidden { display: none !important; }

        /* èƒ½åŠ›èª¬æ˜ãƒãƒƒãƒ— */
        #ability-desc {
            font-weight: bold;
            color: #1976d2;
            min-height: 2.5em; /* 2è¡Œåˆ†ç¢ºä¿ */
            font-size: 0.85rem;
            max-width: 250px;
            margin: 0 auto;
        }

        /* ä¸Šéƒ¨ã®ä¸¸ãƒœã‚¿ãƒ³ç¾¤ï¼ˆæˆ»ã‚‹ãƒ»éŸ³ãƒ»å…¨ç”»é¢ï¼‰ */
        .top-bubble-btn {
            position: absolute;
            top: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: 2px solid #fff;
            border-radius: 50%;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 999; /* UIã‚ˆã‚Šå‰é¢ã« */
            user-select: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            transition: transform 0.1s, opacity 0.2s;
            touch-action: manipulation;
        }
        .top-bubble-btn:active { transform: scale(0.9); }
        .top-bubble-btn.disabled { opacity: 0.35; pointer-events: none; }

        #btn-back { left: 15px; font-size: 22px; }
        #sound-switch { left: 65px; }
        #fullscreen-switch { left: 115px; font-size: 18px; }

        /* æ¨ªç”»é¢å¯¾å¿œç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        #landscape-warning {
            display: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éè¡¨ç¤º */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            color: #fff;
            z-index: 99999; /* æœ€å‰é¢ */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #landscape-warning .icon {
            font-size: 50px;
            margin-bottom: 20px;
            animation: rotate-phone 2s infinite ease-in-out;
        }

        @keyframes rotate-phone {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-90deg); }
            75% { transform: rotate(-90deg); }
            100% { transform: rotate(0deg); }
        }

        @media screen and (orientation: portrait) {
            #landscape-warning {
                display: flex !important;
            }
            #game-wrapper {
                display: none !important;
            }
        }

        @media screen and (max-height: 500px) {
            h1 { font-size: 1.5rem; margin-bottom: 5px; }
            .ui-content { padding: 10px; max-height: 95%; }
            button { padding: 8px 16px; margin: 3px; font-size: 0.9rem; }
            h2 { font-size: 1.2rem; margin: 5px 0; }
            p { font-size: 0.8rem; margin: 5px 0; }
        }

    </style>
</head>
<body>

    <!-- æ¨ªç”»é¢ã®ãŠé¡˜ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ -->
    <div id="landscape-warning">
        <div class="icon">ğŸ“± âŸ²</div>
        <h2>ç«¯æœ«ã‚’æ¨ªã«ã—ã¦ãã ã•ã„</h2>
        <p>Please rotate your device<br>to play the game.</p>
    </div>

<div id="game-wrapper">
    <canvas id="main-canvas" width="800" height="450"></canvas>

    <!-- æˆ»ã‚‹ãƒœã‚¿ãƒ³ï¼ˆè¿½åŠ ï¼‰ -->
    <div id="btn-back" class="top-bubble-btn">â†</div>

    <!-- éŸ³å£°åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ -->
    <div id="sound-switch" class="top-bubble-btn">ğŸ”Š</div>

    <!-- å…¨ç”»é¢ãƒœã‚¿ãƒ³ï¼ˆè¿½åŠ ï¼‰ -->
    <div id="fullscreen-switch" class="top-bubble-btn" title="Fullscreen">â›¶</div>

    <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
    <div id="screen-title" class="ui-layer">
        <div class="ui-content">
            <h1>2026 HAPPY HORSE RACE</h1>
            <p>è‡ªåˆ†ã§ä½œã£ãŸé¦¬ã§èµ°ã‚ŠæŠœã‘ã‚ï¼<br>2026å¹´ æ–°æ˜¥ç«¶é¦¬ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</p>
            <p style="font-size: 0.8rem; color: #666;">éŸ³ãŒå‡ºã¾ã™ã€‚å·¦ä¸Šã®ãƒœã‚¿ãƒ³ã§OFFã«ã§ãã¾ã™ã€‚</p>
            <button onclick="Game.toCustomize()">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <button class="secondary" onclick="Game.showHowTo()">éŠã³æ–¹</button>

            <!-- â˜… ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆï¼ˆè¿½åŠ ï¼‰ -->
            <div class="credit">Game Design &amp; Development : ICHI KUMAGAI</div>
        </div>
    </div>

    <!-- éŠã³æ–¹ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="screen-howto" class="ui-layer hidden">
        <div class="ui-content" style="max-width: 600px;">
            <h2>éŠã³æ–¹</h2>
            <p><strong>PCæ“ä½œ:</strong><br>
            [ã‚¹ãƒšãƒ¼ã‚¹] / [â†‘] : ã‚¸ãƒ£ãƒ³ãƒ—<br>
            [â†’] é€£æ‰“ : ãƒ€ãƒƒã‚·ãƒ¥ï¼ˆã‚¹ã‚¿ãƒŸãƒŠæ¶ˆè²»ï¼‰<br>
            [Z] / [Enter] : ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆç«ã®ç‰ãªã©ï¼‰</p>
            <p><strong>ã‚¹ãƒãƒ›æ“ä½œ:</strong><br>
            [JUMP] : ã‚¸ãƒ£ãƒ³ãƒ—<br>
            [DASH] é€£æ‰“ : ãƒ€ãƒƒã‚·ãƒ¥<br>
            [FIRE] : ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆèƒ½åŠ›æŒã¡ã®ã¿ï¼‰</p>
            <button onclick="Game.hideHowTo()">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºç”»é¢ -->
    <div id="screen-customize" class="ui-layer hidden">
        <div class="ui-content" style="min-width: 500px;">
            <h2>é¦¬ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º</h2>
            <div style="display:flex; flex-wrap:wrap; justify-content:center; align-items:flex-start;">
                <div style="margin: 10px;">
                    <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ (300x200) -->
                    <canvas id="preview-canvas" width="300" height="200"></canvas>
                    <div id="ability-desc">èƒ½åŠ›: ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—</div>
                </div>
                <div>
                    <div class="parts-selector">
                        <div class="part-group">
                            <label>é¡”</label><br>
                            <button onclick="Customizer.changePart('head', -1)">â†</button>
                            <span id="label-head">1</span>
                            <button onclick="Customizer.changePart('head', 1)">â†’</button>
                        </div>
                        <div class="part-group">
                            <label>ä½“</label><br>
                            <button onclick="Customizer.changePart('body', -1)">â†</button>
                            <span id="label-body">1</span>
                            <button onclick="Customizer.changePart('body', 1)">â†’</button>
                        </div>
                        <div class="part-group">
                            <label>è¶³</label><br>
                            <button onclick="Customizer.changePart('legs', -1)">â†</button>
                            <span id="label-legs">1</span>
                            <button onclick="Customizer.changePart('legs', 1)">â†’</button>
                        </div>
                    </div>
                    <div style="font-size:0.9rem;">ã‚«ãƒ©ãƒ¼é¸æŠï¼ˆèƒ½åŠ›ãŒå¤‰ã‚ã‚Šã¾ã™ï¼‰</div>
                    <div class="color-grid" id="color-palette"></div>
                </div>
            </div>
            <button onclick="Game.toModeSelect()">ã“ã®é¦¬ã§èµ°ã‚‹ï¼</button>
        </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ‰é¸æŠç”»é¢ -->
    <div id="screen-mode" class="ui-layer hidden">
        <div class="ui-content">
            <h2>é›£æ˜“åº¦ã‚’é¸ã‚“ã§ãã ã•ã„</h2>
            <button class="danger" onclick="Game.startGame('GACHI')">ã‚¬ãƒã‚¹ãƒ†ãƒ¼ã‚¸</button>
            <p style="font-size: 0.8rem;">å®ŸåŠ›å‹è² ã€‚ã‹ãªã‚Šé›£ã—ã„ã§ã™ã€‚</p>
            <br>
            <button class="secondary" onclick="Game.startGame('HAPPY')">ãƒãƒƒãƒ”ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¸</button>
            <p style="font-size: 0.8rem;">2026å¹´ã‚’ãƒãƒƒãƒ”ãƒ¼ã«ã€‚<br>ãƒãƒƒãƒ”ãƒ¼ãªã‚¢ã‚¯ã‚·ãƒ‡ãƒ³ãƒˆã‚‚...ï¼Ÿ</p>
        </div>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ä¸­UI (ã‚¹ãƒãƒ›ç”¨) -->
    <div id="game-ui">
        <div class="touch-controls">
            <div class="touch-btn" id="btn-fire">FIRE</div>
            <div class="touch-btn" id="btn-dash">DASH</div>
            <div class="touch-btn" id="btn-jump">JUMP</div>
        </div>
    </div>

    <!-- ãƒªã‚¶ãƒ«ãƒˆç”»é¢ -->
    <div id="screen-result" class="ui-layer hidden">
        <div class="ui-content">
            <h1 id="result-rank">1ç€</h1>
            <h2 id="result-msg">2026 HAPPY NEW YEAR!!</h2>
            <p style="font-size: 1.5rem; color: gold; text-shadow: 1px 1px 0 #000;">
                è³é‡‘: <span id="result-prize">2026ä¸‡</span>å††
            </p>
            <button id="result-btn" onclick="Game.toTitle()">ã‚‚ã†ä¸€åº¦éŠã¶</button>
        </div>
    </div>

    <!-- ãƒœãƒ¼ãƒŠã‚¹å‹•ç”»ç”»é¢ -->
    <div id="screen-bonus-video" class="ui-layer hidden">
        <div class="ui-content">
            <h2 style="color:gold;">CONGRATULATIONS!!</h2>
            <video id="bonus-video" src="bonus.mp4" controls playsinline></video>
            <br>
            <button onclick="Game.toTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
        </div>
    </div>

</div>

<script>
/**
 * 2026 HAPPY HORSE RACE
 * v8 Final + Back + Fullscreen + CPU speed tweak
 */

// --- è¨­å®šãƒ»å®šæ•° ---
const CONFIG = {
    CANVAS_WIDTH: 800,
    CANVAS_HEIGHT: 450,
    GRAVITY: 0.6,
    JUMP_POWER: -12,
    BASE_SPEED: 5,
    DASH_SPEED_MULT: 1.6,
    TIRED_SPEED_MULT: 0.5,
    MAX_STAMINA: 100,
    STAMINA_COST_DASH: 1.0,
    STAMINA_RECOVERY_BASE: 0.3,
    STAMINA_RECOVERY_ITEM: 40,
    GAME_DURATION_SEC: 30,
    GROUND_Y: 350,
    BASE_IMAGE_SCALE: 0.15
};

// ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«å®šç¾©
const IMAGE_FILES = {
    head: ['head_01.png', 'head_02.png', 'head_03.png', 'head_04.png', 'head_05.png'],
    body: ['body_01.png', 'body_02.png', 'body_03.png', 'body_04.png', 'body_05.png'],
    legs: ['legs_01.png', 'legs_02.png', 'legs_03.png', 'legs_04.png', 'legs_05.png']
};

// --- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œãƒ­ã‚¸ãƒƒã‚¯ ---
function resizeGame() {
    const wrapper = document.getElementById('game-wrapper');
    const winW = window.innerWidth;
    const winH = window.innerHeight;

    const gameAspect = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
    const winAspect = winW / winH;

    let scale;
    if (winAspect > gameAspect) {
        scale = winH / CONFIG.CANVAS_HEIGHT;
    } else {
        scale = winW / CONFIG.CANVAS_WIDTH;
    }

    wrapper.style.transform = `scale(${scale})`;
}
window.addEventListener('resize', resizeGame);
window.addEventListener('load', resizeGame);

// --- è‰²ã¨èƒ½åŠ›ã®å®šç¾© ---
const ABILITIES = {
    "#ffff00": { type: "stamina", name: "ç„¡é™ã®ä½“åŠ›", staminaSave: 0.1, desc: "ã‚¹ã‚¿ãƒŸãƒŠæ¶ˆè²»ãŒæ¿€æ¸›" },
    "#ffd700": { type: "stamina", name: "ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ãƒ©ãƒ³ã‚°", staminaSave: 0.4, desc: "ã‚¹ã‚¿ãƒŸãƒŠæ¶ˆè²»ãŒã‹ãªã‚Šå°‘ãªã„" },
    "#f0e68c": { type: "stamina", name: "ã‚¿ãƒ•ãƒã‚¹", staminaSave: 0.6, desc: "ã‚¹ã‚¿ãƒŸãƒŠæ¶ˆè²»ãŒå°‘ãªã„" },
    "#ffa500": { type: "speed", name: "ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ã‚¿ãƒ¼", speedBonus: 1.8, desc: "åŸºæœ¬é€Ÿåº¦ãŒã‹ãªã‚Šé€Ÿã„" },
    "#ff4500": { type: "speed", name: "ãƒ©ãƒ”ãƒƒãƒ‰", speedBonus: 1.4, desc: "åŸºæœ¬é€Ÿåº¦ãŒé€Ÿã„" },
    "#ff8c00": { type: "speed", name: "ã‚¯ã‚¤ãƒƒã‚¯", speedBonus: 1.15, desc: "åŸºæœ¬é€Ÿåº¦ãŒå°‘ã—é€Ÿã„" },
    "#0000ff": { type: "double_jump", name: "ãƒ€ãƒ–ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—", jumps: 2, desc: "2æ®µã‚¸ãƒ£ãƒ³ãƒ—ãŒå¯èƒ½" },
    "#1e90ff": { type: "triple_jump", name: "ãƒˆãƒªãƒ—ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—", jumps: 3, desc: "3æ®µã‚¸ãƒ£ãƒ³ãƒ—ãŒå¯èƒ½" },
    "#000080": { type: "quad_jump", name: "ã‚¨ã‚¢ã‚¦ã‚©ãƒ¼ã‚¯", jumps: 4, desc: "4æ®µã‚¸ãƒ£ãƒ³ãƒ—ãŒå¯èƒ½" },
    "#800080": { type: "penta_jump", name: "æœˆæ­©", jumps: 5, desc: "5æ®µã‚¸ãƒ£ãƒ³ãƒ—ãŒå¯èƒ½" },
    "#00ffff": { type: "fly", name: "ã‚¹ã‚«ã‚¤ãƒã‚¤", desc: "ã‚¸ãƒ£ãƒ³ãƒ—ä¸­ã«æµ®éŠã§ãã‚‹" },
    "#afeeee": { type: "fly", name: "ã‚°ãƒ©ã‚¤ãƒ€ãƒ¼", desc: "ã‚†ã£ãã‚Šæ»‘ç©ºã§ãã‚‹" },
    "#00ff00": { type: "high_jump", name: "ãƒãƒƒã‚¿ã‚¸ãƒ£ãƒ³ãƒ—", jumpBonus: 7, desc: "ã‚¸ãƒ£ãƒ³ãƒ—åŠ›ãŒã‚ã¡ã‚ƒé«˜ã„" },
    "#32cd32": { type: "high_jump", name: "ã‚«ã‚¨ãƒ«", jumpBonus: 1.5, desc: "ã‚¸ãƒ£ãƒ³ãƒ—åŠ›ãŒé«˜ã„" },
    "#000000": { type: "giant", name: "ã‚®ã‚¬ãƒ³ãƒˆ", scale: 3, desc: "ä½“ãŒå…ƒã‹ã‚‰å¤§ãã„" },
    "#2f4f4f": { type: "giant", name: "ãƒ“ãƒƒã‚°", scale: 1.3, desc: "ä½“ãŒå°‘ã—å¤§ãã„" },
    "#ffffff": { type: "mini", name: "ãƒ‰ãƒ¯ãƒ¼ãƒ•", scale: 0.3, desc: "ä½“ãŒå…ƒã‹ã‚‰å°ã•ã„" },
    "#f5f5f5": { type: "mini", name: "ã‚¹ãƒ¢ãƒ¼ãƒ«", scale: 0.8, desc: "ä½“ãŒå°‘ã—å°ã•ã„" },
    "#8a2be2": { type: "ghost", name: "ã‚´ãƒ¼ã‚¹ãƒˆ", desc: "æ•µã¨éšœå®³ç‰©ã‚’ã™ã‚ŠæŠœã‘ã‚‹" },
    "#4b0082": { type: "ghost", name: "ãƒ•ã‚¡ãƒ³ãƒˆãƒ ", desc: "æ•µã¨éšœå®³ç‰©ã‚’ã™ã‚ŠæŠœã‘ã‚‹" },
    "#ff0000": { type: "shoot", name: "ãƒ‰ãƒ©ã‚´ãƒ³ãƒ–ãƒ¬ã‚¹", desc: "Zã‚­ãƒ¼ã§ç«ã®ç‰ã‚’ç™ºå°„ï¼" },
    "#dc143c": { type: "shoot", name: "ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«", desc: "Zã‚­ãƒ¼ã§ç«ã®ç‰ã‚’ç™ºå°„ï¼" },
    "#a0522d": { type: "accel", name: "ã‚¹ãƒ­ãƒ¼ã‚¹ã‚¿ãƒ¼ã‚¿ãƒ¼", desc: "æœ€åˆã¯é…ã„ãŒå¾ŒåŠé€Ÿããªã‚‹" },
    "#8b4513": { type: "accel", name: "å¤§å™¨æ™©æˆ", desc: "å¾ŒåŠã©ã‚“ã©ã‚“é€Ÿããªã‚‹" },
    "#c0c0c0": { type: "decel", name: "å…ˆè¡Œé€ƒã’åˆ‡ã‚Š", desc: "æœ€åˆã¯é€Ÿã„ãŒå¾ŒåŠãƒãƒ†ã‚‹" },
    "#d3d3d3": { type: "decel", name: "ãƒ­ã‚±ãƒƒãƒˆã‚¹ã‚¿ãƒ¼ãƒˆ", desc: "ã‚¹ã‚¿ãƒ¼ãƒˆãƒ€ãƒƒã‚·ãƒ¥ç‰¹åŒ–" },
    "#adff2f": { type: "glass", name: "ã‚¬ãƒ©ã‚¹ã®ã‚¨ãƒ¼ã‚¹", desc: "ä½“åŠ›ã¯ãªã„ãŒè¶…é«˜é€Ÿ" },
    "#556b2f": { type: "tank", name: "é‡æˆ¦è»Š", desc: "é…ã„ãŒä½“åŠ›ã¯ç„¡é™" },
    "#ff69b4": { type: "double_jump", name: "ã‚¢ã‚¤ãƒ‰ãƒ«", jumps: 2, desc: "2æ®µã‚¸ãƒ£ãƒ³ãƒ—" },
    "#ffc0cb": { type: "high_jump", name: "ãƒ©ãƒ“ãƒƒãƒˆ", jumpBonus: 1.4, desc: "ã‚¸ãƒ£ãƒ³ãƒ—åŠ›é«˜ã‚" },
    "SECRET": { type: "god", name: "ä¼èª¬ã®é¦¬", desc: "å…¨ã¦ã‚’å…¼ã­å‚™ãˆãŸæœ€å¼·ã®é¦¬" }
};
const PALETTE_COLORS = Object.keys(ABILITIES).filter(k => k !== "SECRET");

// --- ç”»åƒã‚¢ã‚»ãƒƒãƒˆç®¡ç† ---
const ASSETS = { head: [], body: [], legs: [] };
function loadImages() {
    ['head', 'body', 'legs'].forEach(part => {
        IMAGE_FILES[part].forEach(filename => {
            const img = new Image();
            img.src = filename;
            ASSETS[part].push(img);
        });
    });
}
loadImages();

// è‰²åˆæˆç”¨ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹
const bufferCanvas = document.createElement('canvas');
bufferCanvas.width = 842;
bufferCanvas.height = 595;
const bCtx = bufferCanvas.getContext('2d');

// --- éŸ³å£°ç”Ÿæˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ ---
class Synthesizer {
    constructor() {
        this.ctx = null;
        this.isMuted = false;
        this.bgmTimer = null;
    }

    init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    toggleMute() {
        this.isMuted = !this.isMuted;
        this.updateBtn();
        if (this.isMuted) this.stopBGM();
        else {
            if (window.Game && window.Game.state === 'RACE' && window.Game.race && !window.Game.race.finished && !window.Game.race.isCountingDown) {
                this.startRaceBGM();
            }
        }
    }

    updateBtn() {
        const btn = document.getElementById('sound-switch');
        if (btn) {
            btn.innerText = this.isMuted ? "ğŸ”‡" : "ğŸ”Š";
            btn.style.opacity = this.isMuted ? "0.5" : "1.0";
        }
    }

    playTone(freq, type, duration, vol=0.1, startTime=0) {
        if (!this.ctx || this.isMuted) return;
        const t = this.ctx.currentTime + startTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, t);
        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + duration);
    }

    playJump() {
        if (!this.ctx || this.isMuted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(300, t);
        osc.frequency.linearRampToValueAtTime(600, t + 0.2);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.2);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.2);
    }

    playDash() { if (!this.ctx || this.isMuted) return; this.playTone(100, 'sawtooth', 0.1, 0.05); }

    playItem(type) {
        if (!this.ctx || this.isMuted) return;
        if (type === 'bad') {
            this.playTone(150, 'sawtooth', 0.3, 0.1);
            this.playTone(100, 'sawtooth', 0.3, 0.1, 0.1);
        } else {
            this.playTone(800, 'sine', 0.1, 0.1);
            this.playTone(1200, 'sine', 0.1, 0.1, 0.1);
        }
    }

    playHit() {
        if (!this.ctx || this.isMuted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.3);
    }

    playShoot() {
        if (!this.ctx || this.isMuted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.2);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, t);
        filter.frequency.linearRampToValueAtTime(100, t + 0.2);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.2);
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.2);
    }

    playFanfare() {
        if (!this.ctx || this.isMuted) return;
        this.stopBGM();
        const now = this.ctx.currentTime;
        const melody = [523, 523, 523, 659, 783, 783, 659, 783, 1046];
        const lens   = [0.1, 0.1, 0.1, 0.2, 0.2, 0.1, 0.1, 0.1, 0.8];
        let t = now;
        melody.forEach((freq, i) => {
            this.playTone(freq, 'square', lens[i], 0.1, t - now);
            t += lens[i];
        });
    }

    startRaceBGM() {
        if (!this.ctx || this.isMuted) return;
        this.stopBGM();
        let beat = 0;
        const bassNotes = [110, 110, 146, 146, 130, 130, 98, 98];
        const loop = () => {
            if (this.isMuted) return;
            const t = this.ctx.currentTime;
            const note = bassNotes[Math.floor(beat/4) % bassNotes.length];
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(t);
            osc.stop(t + 0.2);
            if (beat % 2 === 0) this.playTone(800, 'square', 0.05, 0.02);
            beat++;
            this.bgmTimer = setTimeout(loop, 125);
        };
        loop();
    }

    stopBGM() { if (this.bgmTimer) clearTimeout(this.bgmTimer); }
}
const Sound = new Synthesizer();

function enableAudioOnFirstTouch() {
    const unlock = () => {
        Sound.init();
        document.removeEventListener('touchstart', unlock);
        document.removeEventListener('click', unlock);
    };
    document.addEventListener('touchstart', unlock);
    document.addEventListener('click', unlock);
}
window.addEventListener('load', enableAudioOnFirstTouch);

// --- é¦¬ã‚¯ãƒ©ã‚¹ ---
class Horse {
    constructor(isPlayer, config, x, y) {
        this.isPlayer = isPlayer;
        this.config = config;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.w = 50;
        this.h = 50;
        this.scale = config.ability.scale || 1.0;
        this.onGround = false;
        this.baseSpeedMod = 1.0;

        this.stamina = (config.ability.type === 'glass') ? 30 : CONFIG.MAX_STAMINA;
        this.maxStamina = (config.ability.type === 'glass') ? 30 : CONFIG.MAX_STAMINA;

        this.jumpCount = 0;
        this.maxJumps = config.ability.jumps || 1;
        if (config.ability.type === 'god') this.maxJumps = 999;

        this.invincible = 0;
        this.shootCooldown = 0;
        this.animationFrame = 0;
    }

    update(input, entities, speedMod = 1.0, frame) {
        let targetSpeed = CONFIG.BASE_SPEED;
        const ab = this.config.ability;
        const isGod = ab.type === 'god';

        let shootReq = false;
        if (this.shootCooldown > 0) this.shootCooldown--;
        if (input.action && (ab.type === 'shoot' || isGod) && this.shootCooldown === 0) {
            shootReq = true;
            this.shootCooldown = 30;
        }

        if (input.dash && this.stamina > 0) {
            let mult = CONFIG.DASH_SPEED_MULT;
            if (isGod) mult *= 2.0;
            targetSpeed *= mult;
            let cost = CONFIG.STAMINA_COST_DASH;
            if (ab.staminaSave) cost *= (1 - ab.staminaSave);
            if (isGod) cost = 0;
            this.stamina -= cost;
        } else {
            this.stamina = Math.min(this.maxStamina, this.stamina + CONFIG.STAMINA_RECOVERY_BASE);
            if (isGod) this.stamina = this.maxStamina;
        }

        if (this.stamina <= 0) {
            this.stamina = 0;
            targetSpeed *= CONFIG.TIRED_SPEED_MULT;
        }

        if (ab.speedBonus) targetSpeed *= ab.speedBonus;
        if (isGod) targetSpeed *= 1.5;

        if (ab.type === 'accel') {
            const factor = Math.min(2.0, 0.8 + (frame / 1800));
            targetSpeed *= factor;
        } else if (ab.type === 'decel') {
            const factor = Math.max(0.6, 1.5 - (frame / 1800));
            targetSpeed *= factor;
        }

        if (ab.type === 'glass' && this.stamina <= 0) targetSpeed *= 1.5;

        const finalTargetSpeed = targetSpeed * speedMod;
        this.vx += (finalTargetSpeed - this.vx) * 0.1;

        let gravity = CONFIG.GRAVITY;
        if ((ab.type === 'fly' || isGod) && input.up && this.vy > 0) gravity = 0.1;
        this.vy += gravity;

        if (input.up && !this.prevUp) {
            if (this.onGround || (this.jumpCount < this.maxJumps)) {
                let power = CONFIG.JUMP_POWER;
                if (ab.jumpBonus) power *= ab.jumpBonus;
                if (this.stamina <= 0) power *= 0.7;
                if (isGod) power *= 1.2;

                this.vy = power;
                this.onGround = false;
                this.jumpCount++;
                if (this.isPlayer) Sound.playJump();
            }
        }
        this.prevUp = input.up;

        this.x += this.vx;
        this.y += this.vy;

        if (this.y + this.h * this.scale > CONFIG.GROUND_Y) {
            this.y = CONFIG.GROUND_Y - this.h * this.scale;
            this.vy = 0;
            this.onGround = true;
            this.jumpCount = 0;
        }

        if (this.invincible > 0) this.invincible--;
        this.animationFrame++;

        return shootReq;
    }

    damage() {
        if (this.config.ability.type === 'god') return;
        this.vx = -5;
        this.stamina = Math.max(0, this.stamina - 20);
        this.invincible = 60;
    }

    getItem(kind) {
        let heal = 0;
        if (kind === 'carrot') heal = CONFIG.STAMINA_RECOVERY_ITEM;
        if (kind === 'drink') heal = CONFIG.MAX_STAMINA;

        if (kind === 'bone') {
            if (this.config.ability.type === 'god') return;
            this.stamina = Math.max(0, this.stamina - 30);
            this.vx *= 0.1;
        } else if (kind === 'big') {
            this.scale = 1.5; setTimeout(() => this.scale = this.config.ability.scale || 1.0, 5000);
            this.stamina = CONFIG.MAX_STAMINA;
        } else if (kind === 'small') {
            this.scale = 0.6; setTimeout(() => this.scale = this.config.ability.scale || 1.0, 5000);
        } else {
            this.stamina = Math.min(this.maxStamina, this.stamina + heal);
            this.vx += 2;
        }
    }

    draw(ctx) {
        if (this.invincible > 0 && Math.floor(this.invincible/4)%2===0) return;
        if (this.config.ability.type === 'god') {
            ctx.save();
            ctx.translate(this.x + 25, this.y + 25);
            ctx.fillStyle = `rgba(255, 215, 0, ${0.3 + Math.sin(Date.now()/100)*0.2})`;
            ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        drawHorse(ctx, this.x, this.y, this.config, this.animationFrame, this.scale, this.stamina <= 0, this.isPlayer);
    }
}

// --- ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ ---
class GameEngine {
    constructor() {
        this.canvas = document.getElementById('main-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.state = 'TITLE';
        this.frame = 0;
        this.loopId = null;

        this.input = { up: false, dash: false, action: false };

        this.playerConfig = {
            headIdx: 0, bodyIdx: 0, legsIdx: 0,
            color: "#800000", ability: ABILITIES["#800000"]
        };

        this.currentMode = '';
        this.lastRank = 0;

        this.setupInput();
        this.previewLoop();
    }

    setupInput() {
        const handleInput = (key, pressed) => {
            if (key === 'Space' || key === 'ArrowUp') this.input.up = pressed;
            if (key === 'ArrowRight' || key === 'KeyD') this.input.dash = pressed;
            if (key === 'KeyZ' || key === 'Enter') this.input.action = pressed;
        };

        window.addEventListener('keydown', (e) => handleInput(e.code, true));
        window.addEventListener('keyup', (e) => handleInput(e.code, false));

        const setupTouch = (id, prop) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.input[prop] = true;
                btn.classList.add('active');
                Sound.init();
                if (prop === 'dash' && this.state === 'RACE') Sound.playDash();
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.input[prop] = false;
                btn.classList.remove('active');
            });
        };
        setupTouch('btn-jump', 'up');
        setupTouch('btn-dash', 'dash');
        setupTouch('btn-fire', 'action');

        document.getElementById('sound-switch').addEventListener('click', (e) => {
            e.stopPropagation();
            Sound.init();
            Sound.toggleMute();
        });
    }

    changeState(newState) {
        this.state = newState;
        document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden'));
        document.getElementById('game-ui').style.display = 'none';

        if (newState === 'TITLE') document.getElementById('screen-title').classList.remove('hidden');
        if (newState === 'CUSTOMIZE') document.getElementById('screen-customize').classList.remove('hidden');
        if (newState === 'MODE') document.getElementById('screen-mode').classList.remove('hidden');
        if (newState === 'RESULT') {
            document.getElementById('screen-result').classList.remove('hidden');

            const btn = document.getElementById('result-btn');
            if (this.currentMode === 'GACHI' && this.lastRank === 1) {
                btn.innerHTML = "ğŸ‘‘ ãƒœãƒ¼ãƒŠã‚¹å‹•ç”»ã‚’è¦‹ã‚‹ ğŸ‘‘";
                btn.classList.add("golden");
                btn.onclick = () => this.showBonusVideo();
            } else {
                btn.innerText = "ã‚‚ã†ä¸€åº¦éŠã¶";
                btn.classList.remove("golden");
                btn.onclick = () => this.toTitle();
            }
        }
        if (newState === 'RACE') {
            document.getElementById('game-ui').style.display = 'block';
            const canShoot = this.playerConfig.ability.type === 'shoot' || this.playerConfig.ability.type === 'god';
            document.getElementById('btn-fire').style.display = canShoot ? 'flex' : 'none';
        }

        if (newState === 'BONUS_VIDEO') {
            document.getElementById('screen-bonus-video').classList.remove('hidden');
            const video = document.getElementById('bonus-video');
            if(video) {
                video.currentTime = 0;
                video.play().catch(e => console.log("Video play failed:", e));
            }
        } else {
            const video = document.getElementById('bonus-video');
            if(video) video.pause();
        }

        updateBackButton();
        Sound.init();
    }

    startRace(mode) {
        this.changeState('RACE');
        this.currentMode = mode;
        this.race = new RaceSession(this, mode, this.playerConfig);
        Sound.stopBGM();
        if (this.loopId) cancelAnimationFrame(this.loopId);
        this.loop();
    }

    showBonusVideo() { this.changeState('BONUS_VIDEO'); }

    toTitle() {
        this.changeState('TITLE');
        this.race = null;
    }

    loop() {
        if (this.state === 'RACE' && this.race) {
            this.ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            this.race.update(this.input);
            this.race.draw(this.ctx);
        }
        this.loopId = requestAnimationFrame(() => this.loop());
    }

    previewLoop() {
        const pCanvas = document.getElementById('preview-canvas');
        const pCtx = pCanvas.getContext('2d');
        const render = () => {
            if (this.state === 'CUSTOMIZE') {
                pCtx.clearRect(0, 0, 300, 200);
                pCtx.fillStyle = "#fff";
                pCtx.fillRect(0,0,300,200);

                pCtx.strokeStyle = "#eee";
                pCtx.beginPath();
                for(let i=0; i<300; i+=20) { pCtx.moveTo(i,0); pCtx.lineTo(i,200); }
                for(let i=0; i<200; i+=20) { pCtx.moveTo(0,i); pCtx.lineTo(300,i); }
                pCtx.stroke();

                drawHorse(pCtx, 135, 100, this.playerConfig, Date.now()/100, 2.5, false, true);
            }
            requestAnimationFrame(render);
        };
        render();
    }
}

// --- ãƒ¬ãƒ¼ã‚¹ç®¡ç†ã‚¯ãƒ©ã‚¹ ---
class RaceSession {
    constructor(engine, mode, pConfig) {
        this.engine = engine;
        this.mode = mode;
        this.frame = 0;
        this.cameraX = 0;
        this.finished = false;
        this.isCountingDown = true;
        this.countDownTimer = 180;
        this.countDownText = "";

        this.goalX = CONFIG.BASE_SPEED * 60 * CONFIG.GAME_DURATION_SEC;

        const startX = 100;
        this.player = new Horse(true, pConfig, startX, CONFIG.GROUND_Y);

        this.cpus = [
            new Horse(false, {color: "#8b4513", headIdx:2, bodyIdx:2, legsIdx:0, ability: ABILITIES["#8b4513"]}, startX, CONFIG.GROUND_Y),
            new Horse(false, {color: "#ffa500", headIdx:1, bodyIdx:1, legsIdx:1, ability: ABILITIES["#ffa500"]}, startX, CONFIG.GROUND_Y)
        ];

        // æ•µã®é€Ÿåº¦è¨­å®šï¼ˆâ˜…ã‚¬ãƒã®æ•µãŒé€Ÿã™ãã‚‹ä»¶ã®èª¿æ•´ï¼‰
        if (mode === 'GACHI') {
            this.cpus[0].baseSpeedMod = 0.985;
            this.cpus[1].baseSpeedMod = 1.005;
        } else {
            this.cpus[0].baseSpeedMod = 0.90;
            this.cpus[1].baseSpeedMod = 0.98;
        }

        this.entities = [];
        this.bullets = [];
        this.generateLevel();
        this.particles = [];
        this.bubbles = [];
    }

    addBubble(x, y, text, color) {
        this.bubbles.push({x, y, text, color, life: 60});
    }

    finishRace() {
        this.finished = true;
        Sound.playFanfare();

        let rank = 1;
        this.cpus.forEach(c => { if (c.x > this.player.x) rank++; });
        this.engine.lastRank = rank;

        if (rank === 1) {
            const spawnCoins = () => {
                if (this.engine.state !== 'RACE') return;
                for(let i=0; i<3; i++) {
                    const type = Math.random();
                    if(type < 0.7) {
                        this.particles.push({
                            x: this.cameraX + Math.random() * CONFIG.CANVAS_WIDTH,
                            y: -50 - Math.random() * 50,
                            vx: (Math.random()-0.5) * 1,
                            vy: 5 + Math.random() * 5,
                            color: '#ffd700',
                            life: 300, w: 20, isCoin: true,
                            rot: Math.random() * Math.PI, rotSpeed: (Math.random()-0.5) * 0.2
                        });
                    } else {
                        this.particles.push({
                             x: this.cameraX + Math.random() * CONFIG.CANVAS_WIDTH,
                             y: -50, vx: (Math.random()-0.5)*3, vy: 2 + Math.random()*3,
                             color: `hsl(${Math.random()*360}, 100%, 50%)`, life: 300, w: 10
                        });
                    }
                }
                requestAnimationFrame(spawnCoins);
            };
            spawnCoins();
        }

        setTimeout(() => {
            document.getElementById('result-rank').innerText = `${rank}ç€ï¼`;
            if (rank === 1) {
                document.getElementById('result-msg').innerText = "2026 HAPPY NEW YEAR!!";
                if (this.mode === 'GACHI') document.getElementById('result-prize').innerText = "2026å„„";
                else document.getElementById('result-prize').innerText = "2026ä¸‡";
            } else {
                document.getElementById('result-msg').innerText = "æ®‹å¿µ...";
                document.getElementById('result-prize').innerText = "0";
            }
            Game.toResult();
        }, 5000);
    }

    generateLevel() {
        let x = 800;
        const density = this.mode === 'GACHI' ? 250 : 300;

        while(x < this.goalX - 800) {
            x += density + Math.random() * 500;

            const type = Math.random();
            if (type < 0.20) {
                this.entities.push({type: 'obstacle', x: x, y: CONFIG.GROUND_Y - 40, w: 40, h: 40, hit: false});
            } else if (type < 0.35) {
                this.entities.push({type: 'pit', x: x, y: CONFIG.GROUND_Y + 10, w: 120, h: 20});
            } else if (type < 0.55) {
                this.entities.push({type: 'enemy_static', x: x, y: CONFIG.GROUND_Y - 40, w: 40, h: 40, alive: true});
            } else if (type < 0.70) {
                this.entities.push({type: 'enemy_moving', x: x, y: CONFIG.GROUND_Y - 60, w: 60, h: 60, alive: true, vx: -1});
            } else {
                const rand = Math.random();
                let itemType = 'carrot';
                if (rand < 0.2) itemType = 'drink';
                else if (rand < 0.4) itemType = 'big';
                else if (rand < 0.6) itemType = 'small';
                else if (rand > 0.85) itemType = 'bone';
                this.entities.push({type: 'item', kind: itemType, x: x, y: CONFIG.GROUND_Y - 80 - Math.random()*80, w: 40, h: 40, taken: false});
            }
        }
    }

    update(input) {
        if (this.isCountingDown) {
            this.countDownTimer--;
            if (this.countDownTimer === 120) Sound.playTone(440, 'square', 0.1);
            if (this.countDownTimer === 60) Sound.playTone(440, 'square', 0.1);
            if (this.countDownTimer === 0) {
                Sound.playTone(880, 'square', 0.4);
                this.countDownText = "";
                this.isCountingDown = false;
                Sound.startRaceBGM();
            } else if (this.countDownTimer > 120) this.countDownText = "ä½ç½®ã«ã¤ã„ã¦...";
            else if (this.countDownTimer > 60) this.countDownText = "ã‚ˆãƒ¼ã„...";
            else this.countDownText = "ãƒ‰ãƒ³ï¼";
            return;
        }

        this.frame++;

        const effectiveInput = this.finished ? { up: false, dash: false, action: false } : input;
        const playerSpeedMod = this.finished ? 0.95 : 1.0;

        const shootReq = this.player.update(effectiveInput, this.entities, playerSpeedMod, this.frame);
        if (shootReq) {
            Sound.playShoot();
            this.bullets.push({ x: this.player.x + 50, y: this.player.y + 20, vx: 12, vy: 0, life: 60, w: 20 });
            this.addBubble(this.player.x, this.player.y-40, "ãƒ•ã‚¡ã‚¤ã‚¢!", "#f44336");
        }

        this.cameraX = this.player.x - 150;
        if (this.cameraX < 0) this.cameraX = 0;

        this.cpus.forEach((cpu) => {
            let jump = false;
            let dash = false;
            let speedMod = cpu.baseSpeedMod;

            if (this.finished) {
                speedMod = 0.95;
            } else {
                const viewDist = 180;
                const obstacleAhead = this.entities.some(e =>
                    (e.type === 'obstacle' || e.type === 'pit' || (e.type.startsWith('enemy') && e.alive)) &&
                    e.x > cpu.x && e.x < cpu.x + viewDist
                );
                if (obstacleAhead && cpu.onGround) jump = true;

                if (cpu.stamina > (this.mode === 'GACHI' ? 10 : 30)) dash = true;
                if (cpu.stamina < 5) dash = false;

                if (this.mode === 'HAPPY') {
                    if (cpu.x > this.goalX - 600) {
                        dash = false;
                        if (cpu.x > this.goalX - 300) { cpu.vx = -2; cpu.stamina = 0; }
                        else { cpu.vx = 0; }
                        speedMod = 0.5;
                        if (this.frame % 120 === 0) {
                            const accidents = [ "ãƒˆã‚¤ãƒ¬è¡ŒããŸã„", "ã‚ã€UFOã ", "Zzz...", "é¦¬åˆºã—é£Ÿã¹ã¦ã€œ" ];
                            const msg = accidents[Math.floor(Math.random() * accidents.length)];
                            this.addBubble(cpu.x, cpu.y - 60, msg, "#ff9");
                        }
                    }
                }
            }
            cpu.update({up: jump, dash: dash, action: false}, [], speedMod, this.frame);
        });

        this.bullets.forEach(b => {
            b.x += b.vx; b.life--;
            this.entities.forEach(e => {
                if (e.type.startsWith('enemy') && e.alive) {
                    if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.w > e.y) {
                        e.alive = false; b.life = 0;
                        Sound.playHit();
                        this.addBubble(e.x, e.y - 30, "é»’ç„¦ã’!", "#000");
                        for(let i=0; i<10; i++) this.particles.push({x: e.x+e.w/2, y: e.y+e.h/2, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, color: '#f00', life: 20, w: 5});
                    }
                }
            });
        });
        this.bullets = this.bullets.filter(b => b.life > 0);

        this.entities.forEach(e => { if (e.type === 'enemy_moving' && e.alive) e.x += e.vx; });

        if (!this.finished) {
            this.entities.forEach(e => {
                if (e.x < this.cameraX - 100 || e.x > this.cameraX + CONFIG.CANVAS_WIDTH + 100) return;

                if (checkRectCollide(this.player, e)) {
                    const isGhost = this.player.config.ability.type === 'ghost' || this.player.config.ability.type === 'god';

                    if (e.type === 'pit') {
                        if (this.player.y > CONFIG.GROUND_Y && !this.player.invincible && this.player.config.ability.type !== 'god') {
                            this.player.damage();
                            this.player.vy = -15;
                            Sound.playHit();
                        }
                    } else if (e.type === 'item' && !e.taken) {
                        e.taken = true;
                        this.player.getItem(e.kind);
                        let msg = "å›å¾©!";
                        if (e.kind === 'drink') msg = "å…¨å¿«!!";
                        if (e.kind === 'bone') msg = "è…ã£ã¦ã‚‹...";
                        if (e.kind === 'big') msg = "å·¨å¤§åŒ–!";
                        if (e.kind === 'small') msg = "ãƒŸãƒ‹åŒ–!";
                        Sound.playItem(e.kind === 'bone' ? 'bad' : 'good');
                        this.addBubble(this.player.x, this.player.y - 50, msg, e.kind==='bone'?'#999':'#0f0');
                    } else {
                        if (isGhost) return;
                        const isStomp = (this.player.vy > 0) && (this.player.y + this.player.h * this.player.scale < e.y + e.h * 0.5);

                        if (e.type === 'obstacle' && !e.hit) {
                            if (this.player.invincible) { e.hit = true; }
                            else { this.player.damage(); e.hit = true; Sound.playHit(); }
                        } else if (e.type.startsWith('enemy') && e.alive) {
                            if (isStomp || this.player.invincible) {
                                e.alive = false;
                                this.player.vy = -10;
                                this.player.stamina = Math.min(CONFIG.MAX_STAMINA, this.player.stamina + 15);
                                this.addBubble(this.player.x, this.player.y - 60, "ã†ã¾ã„ï¼", "#ffeb3b");
                                Sound.playItem('good');
                                for(let i=0; i<15; i++) this.particles.push({x: e.x+e.w/2, y: e.y+e.h/2, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, color: '#fff', life: 30, w: 6});
                            } else {
                                this.player.damage();
                                Sound.playHit();
                            }
                        }
                    }
                }
            });
        }

        this.bubbles = this.bubbles.filter(b => b.life > 0);
        this.bubbles.forEach(b => { b.life--; b.y -= 0.5; });

        this.particles.forEach(p => {
            p.x += p.vx; p.y += p.vy;
            if(p.isCoin) { p.vy += 0.3; p.rot += p.rotSpeed; }
            p.life--;
        });
        this.particles = this.particles.filter(p => p.life > 0);

        if (!this.finished && this.player.x >= this.goalX) this.finishRace();
    }

    draw(ctx) {
        ctx.fillStyle = "#87CEEB";
        ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

        //ï¼ˆä»¥ä¸‹ã€çœç•¥ãªã—ã§å…ƒã®ã¾ã¾ã€‚é•·ã„ã®ã§ã“ã®ã¾ã¾è²¼ã‚Šç¶šã‘ã¾ã™ï¼‰
        // ã“ã“ä»¥é™ã® draw()ãƒ»æç”»ãƒ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã¯ã€Œã‚ãªãŸãŒè²¼ã£ã¦ãã‚ŒãŸã‚³ãƒ¼ãƒ‰ã€ã‹ã‚‰ä¸€åˆ‡ã„ã˜ã£ã¦ã¾ã›ã‚“ã€‚
        // ã™ã§ã«é•·å¤§ãªã®ã§ã€é€”ä¸­æ”¹å¤‰ãŒèµ·ããªã„ã‚ˆã† â€œã“ã®ä¸‹ã¯ãã®ã¾ã¾â€ ã«ã—ã¦ã„ã¾ã™ã€‚

        ctx.save();
        ctx.translate(-this.cameraX * 0.5, 0);
        ctx.fillStyle = "#e0e0e0";
        ctx.fillRect(0, 100, this.goalX + 2000, 250);
        const crowdStartX = Math.floor((this.cameraX * 0.5) / 20) * 20 - 100;
        const crowdEndX = crowdStartX + CONFIG.CANVAS_WIDTH + 200;
        for (let row = 0; row < 6; row++) {
            const rowY = 120 + row * 30;
            for (let cx = crowdStartX; cx < crowdEndX; cx += 15) {
                const seed = (cx * 1.3 + row * 7.1 + Math.floor(cx/1000));
                const hue = Math.abs(Math.sin(seed) * 360);
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                const jump = (Math.sin(this.frame * 0.1 + cx) > 0.8) ? 3 : 0;
                ctx.fillRect(cx, rowY + 15 - jump, 12, 15);
                ctx.fillStyle = `hsl(${hue}, 70%, 70%)`;
                ctx.beginPath(); ctx.arc(cx + 6, rowY + 8 - jump, 5, 0, Math.PI * 2); ctx.fill();
            }
        }
        ctx.restore();

        ctx.save();
        ctx.translate(-this.cameraX, 0);

        ctx.fillStyle = "#8d6e63";
        ctx.fillRect(0, CONFIG.GROUND_Y, this.goalX + 2000, 200);
        ctx.fillStyle = "#4caf50";
        ctx.fillRect(0, CONFIG.GROUND_Y, this.goalX + 2000, 15);

        for(let d=0; d<this.goalX; d+=1000) {
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillRect(d, CONFIG.GROUND_Y+15, 10, 50);
            ctx.fillStyle = "#fff";
            ctx.font = "16px sans-serif";
            ctx.fillText((d/10)+"m", d, CONFIG.GROUND_Y+80);
        }
        ctx.fillStyle = "#fff";
        ctx.fillRect(100, CONFIG.GROUND_Y, 10, 200);

        drawGoal(ctx, this.goalX);

        this.entities.forEach(e => {
            if (e.x < this.cameraX - 100 || e.x > this.cameraX + 900) return;

            if (e.type === 'obstacle' && !e.hit) {
                ctx.fillStyle = "#d32f2f"; ctx.fillRect(e.x, e.y, e.w, e.h);
                ctx.fillStyle = "#fff"; ctx.fillRect(e.x, e.y, e.w, 10);
            } else if (e.type === 'pit') {
                ctx.fillStyle = "#222"; ctx.fillRect(e.x, e.y, e.w, 100);
            } else if (e.type === 'enemy_static' && e.alive) {
                ctx.fillStyle = "#8d6e63"; ctx.fillRect(e.x+10, e.y+20, 20, 20);
                ctx.fillStyle = "#ff5722"; ctx.beginPath(); ctx.arc(e.x+20, e.y+20, 20, Math.PI, 0); ctx.fill();
                ctx.fillStyle = "#fff"; ctx.fillText("ğŸ’€", e.x+10, e.y+35);
            } else if (e.type === 'enemy_moving' && e.alive) {
                const bx = e.x, by = e.y, bw = e.w, bh = e.h;
                ctx.fillStyle = "#555";
                ctx.fillRect(bx+10, by+10, bw-20, bh-10); ctx.fillRect(bx+15, by, 30, 20);
                ctx.fillRect(bx+10, by-5, 10, 10); ctx.fillRect(bx+40, by-5, 10, 10);
                ctx.fillRect(bx, by, 10, 30); ctx.fillRect(bx+bw-10, by, 10, 30);
                ctx.fillStyle = "#fbc02d";
                ctx.fillRect(bx, by-5, 3, 5); ctx.fillRect(bx+3, by-5, 3, 5); ctx.fillRect(bx+6, by-5, 3, 5);
                ctx.fillStyle = "#555"; ctx.fillRect(bx+10, by+bh-5, 15, 10);
                ctx.fillStyle = "#d32f2f"; ctx.fillRect(bx+23, by+15, 14, 10);
            } else if (e.type === 'item' && !e.taken) {
                ctx.font = "40px Arial";
                let icon = "ğŸ¥•";
                if(e.kind==='bone') icon="ğŸ–"; if(e.kind==='drink') icon="ğŸ¥¤";
                if(e.kind==='big') icon="ğŸ„"; if(e.kind==='small') icon="ğŸ§";
                const floatY = Math.sin(this.frame * 0.1) * 5;
                ctx.fillText(icon, e.x, e.y + 35 + floatY);
            }
        });

        this.bullets.forEach(b => {
            ctx.fillStyle = "#ff4500";
            ctx.beginPath(); ctx.arc(b.x, b.y, b.w/2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#ffff00";
            ctx.beginPath(); ctx.arc(b.x-2, b.y-2, b.w/4, 0, Math.PI*2); ctx.fill();
        });

        this.cpus.forEach(c => c.draw(ctx));
        this.player.draw(ctx);

        this.bubbles.forEach(b => {
            ctx.fillStyle = "rgba(255,255,255,0.9)";
            ctx.beginPath(); ctx.roundRect(b.x, b.y, 80, 26, 5); ctx.fill();
            ctx.fillStyle = "#000";
            ctx.font = "18px bold sans-serif";
            ctx.fillText(b.text, b.x + 5, b.y + 18);
        });

        this.particles.forEach(p => {
            if (p.isCoin) {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.scale(Math.cos(p.rot), 1);
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(0, 0, p.w/2, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = "#b8860b"; ctx.lineWidth = 2; ctx.stroke();
                ctx.restore();
            } else {
                ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.w, p.w);
            }
        });

        ctx.restore();

        if (this.isCountingDown) {
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            ctx.fillStyle = "#fff";
            ctx.font = "bold 80px Verdana";
            ctx.textAlign = "center";
            ctx.fillText(this.countDownText, CONFIG.CANVAS_WIDTH/2, CONFIG.CANVAS_HEIGHT/2);
            ctx.textAlign = "left"; return;
        }

        let rank = 1;
        this.cpus.forEach(c => { if(c.x > this.player.x) rank++; });
        ctx.fillStyle = "#000";
        ctx.font = "bold 24px Verdana";
        ctx.fillText(`${rank}ä½ / 3é ­`, 20, 40);

        ctx.fillStyle = "#333";
        ctx.fillRect(20, 50, 204, 24);
        const ratio = this.player.stamina / CONFIG.MAX_STAMINA;
        ctx.fillStyle = ratio > 0.5 ? "#00e676" : (ratio > 0.2 ? "#ffea00" : "#ff1744");
        ctx.fillRect(22, 52, 200 * ratio, 20);
        ctx.fillStyle = "#fff";
        ctx.font = "14px Verdana";
        ctx.fillText("STAMINA", 25, 67);

        if (this.player.config.ability.type === 'god') {
            ctx.fillStyle = "gold"; ctx.font = "bold 20px Verdana"; ctx.fillText("â˜…GOD MODEâ˜…", 240, 70);
            ctx.fillStyle = "gold"; ctx.fillRect(22, 52, 200, 20);
        } else if (this.player.stamina < 10) {
            ctx.fillStyle = "red"; ctx.font = "bold 20px Verdana"; ctx.fillText("ãƒãƒ†æ°—å‘³... é€£æ‰“ã‚’æ§ãˆã‚ï¼", 240, 70);
        } else if (this.engine.input.dash) {
            ctx.fillStyle = "orange"; ctx.font = "bold 20px Verdana"; ctx.fillText("DASH!!!", 240, 70);
        }
    }
}

// --- æç”»ï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ï¼‰ ---
function drawHorse(ctx, x, y, config, frame, scale, isTired, isPlayer = false) {
    ctx.save();
    ctx.translate(x, y);

    const headImg = ASSETS.head[config.headIdx];
    const bodyImg = ASSETS.body[config.bodyIdx];
    const legsImg = ASSETS.legs[config.legsIdx];

    const isLoaded = (img) => img && img.complete && img.naturalHeight !== 0;
    const hasImage = isPlayer && isLoaded(headImg) && isLoaded(bodyImg) && isLoaded(legsImg);

    let currentScale = scale;
    if (hasImage) currentScale = scale * CONFIG.BASE_IMAGE_SCALE;
    ctx.scale(currentScale, currentScale);

    let bounce = Math.sin(frame * 0.5) * (hasImage ? 50 : 5);
    if (isTired) bounce *= 0.2;
    ctx.translate(0, bounce);

    const c = config.color;

    if (hasImage) {
        drawPartImage(ctx, legsImg, c);
        drawPartImage(ctx, bodyImg, c);

        ctx.save();
        if (isTired) ctx.rotate(Math.PI / 6);
        drawPartImage(ctx, headImg, c);

        if (isTired) {
            ctx.fillStyle = "#00f";
            ctx.font = "100px sans-serif";
            ctx.fillText("ğŸ’¦", 100, 0);
        }
        ctx.restore();
    } else {
        ctx.fillStyle = "#000";
        let legSpeed = isTired ? 0.2 : 0.5;
        if (config.ability.type === 'god') legSpeed = 1.0;
        const legOffset = Math.sin(frame * legSpeed) * 10;

        drawPartShape(ctx, config.legsIdx, -10 + legOffset, 30, c, 10, 20);
        drawPartShape(ctx, config.legsIdx, 30 - legOffset, 30, c, 10, 20);

        drawPartShape(ctx, config.bodyIdx, 0, 10, c, 50, 30);

        ctx.save();
        if (isTired) ctx.rotate(Math.PI / 6);
        drawPartShape(ctx, config.headIdx, 30, -10, c, 25, 25);

        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(45, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#000";
        if (isTired) {
            ctx.font = "10px sans-serif"; ctx.fillText("Ã—", 43, 4);
        } else {
            ctx.beginPath(); ctx.arc(47, 0, 2, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();

        if (isTired) {
            ctx.fillStyle = "#00f";
            ctx.font = "12px sans-serif";
            ctx.fillText("ğŸ’¦", 10, 0);
        }

        ctx.fillStyle = "brown";
        ctx.fillRect(15, 10, 20, 15);
    }

    ctx.restore();
}

function drawPartImage(ctx, img, color) {
    bCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
    bCtx.drawImage(img, 0, 0);
    bCtx.globalCompositeOperation = 'source-in';
    bCtx.fillStyle = color;
    bCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
    bCtx.globalCompositeOperation = 'source-over';
    ctx.drawImage(bufferCanvas, -bufferCanvas.width/2, -bufferCanvas.height/2);
}

function drawPartShape(ctx, typeIdx, x, y, color, w, h) {
    if (color === '#gold') ctx.fillStyle = `hsl(50, 100%, ${50 + Math.sin(Date.now()/200)*20}%)`;
    else ctx.fillStyle = color;

    if (typeIdx === 0) { ctx.fillRect(x, y, w, h); }
    else if (typeIdx === 1) { ctx.beginPath(); ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI*2); ctx.fill(); }
    else if (typeIdx === 2) { ctx.beginPath(); ctx.moveTo(x, y+h); ctx.lineTo(x+w/2, y); ctx.lineTo(x+w, y+h); ctx.fill(); }
    else if (typeIdx === 3) { ctx.fillRect(x + w*0.25, y, w*0.5, h); }
    else { ctx.fillRect(x, y, w, h); ctx.fillStyle = "rgba(255,255,255,0.3)"; ctx.fillRect(x+2, y+2, w-4, h-4); }
}

function drawGoal(ctx, x) {
    ctx.fillStyle = "#ddd";
    ctx.fillRect(x, CONFIG.GROUND_Y - 200, 20, 200);
    ctx.fillRect(x + 200, CONFIG.GROUND_Y - 200, 20, 200);
    ctx.fillStyle = "#d32f2f";
    ctx.fillRect(x, CONFIG.GROUND_Y - 200, 220, 50);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 30px Arial";
    ctx.fillText("2026", x + 70, CONFIG.GROUND_Y - 165);
    const size = 20;
    for(let i=0; i<10; i++) {
        for(let j=0; j<8; j++) {
            ctx.fillStyle = ((i+j)%2===0) ? "#000" : "#fff";
            ctx.fillRect(x + 20 + i*size, CONFIG.GROUND_Y - 150 + j*size, size, size);
        }
    }
}

function checkRectCollide(r1, r2) {
    const hx = r1.x + 10;
    const hy = r1.y + 10;
    const hw = r1.w * r1.scale - 20;
    const hh = r1.h * r1.scale - 10;
    return (hx < r2.x + r2.w && hx + hw > r2.x && hy < r2.y + r2.h && hy + hh > r2.y);
}

// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«ç®¡ç† ---
const Game = new GameEngine();

const Customizer = {
    changePart: (part, dir) => {
        let idx = Game.playerConfig[part + "Idx"];
        idx += dir;
        if (idx < 0) idx = 4; if (idx > 4) idx = 0;
        Game.playerConfig[part + "Idx"] = idx;
        document.getElementById(`label-${part}`).innerText = idx + 1;
    },
    setColor: (color, isSecret = false) => {
        if (isSecret) {
            Game.playerConfig.color = '#gold';
            Game.playerConfig.ability = ABILITIES["SECRET"];
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById(`btn-secret`).classList.add('selected');
        } else {
            Game.playerConfig.color = color;
            Game.playerConfig.ability = ABILITIES[color] || {type:'normal', name:'ãƒãƒ¼ãƒãƒ«'};
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            const el = document.getElementById(`btn-${color}`);
            if (el) el.classList.add('selected');
        }

        let desc = Game.playerConfig.ability.name;
        if (Game.playerConfig.ability.desc) {
             desc += `<br><span style="font-size:0.8em; color:#555;">${Game.playerConfig.ability.desc}</span>`;
        }
        document.getElementById('ability-desc').innerHTML = desc;
    }
};

// ===== æˆ»ã‚‹ãƒœã‚¿ãƒ³ï¼ˆè¿½åŠ ï¼‰ =====
function updateBackButton() {
    const btn = document.getElementById('btn-back');
    if (!btn) return;

    // ã‚¿ã‚¤ãƒˆãƒ«ãƒ»ãƒ¬ãƒ¼ã‚¹ä¸­ã¯æˆ»ã‚‹ã‚’å‡ºã•ãªã„ï¼ˆèª¤æ“ä½œé˜²æ­¢ï¼‰
    if (Game.state === 'TITLE' || Game.state === 'RACE') {
        btn.classList.add('disabled');
        btn.style.display = 'none';
        return;
    }
    btn.style.display = 'flex';
    btn.classList.remove('disabled');
}

function handleBack() {
    // stateã”ã¨ã®ã€Œå‰ã«æˆ»ã‚‹ã€ã‚’å®šç¾©ï¼ˆåˆ†ã‹ã‚Šã‚„ã™ã„å›ºå®šé·ç§»ï¼‰
    if (Game.state === 'CUSTOMIZE') {
        Game.toTitle();
    } else if (Game.state === 'MODE') {
        Game.toCustomize();
    } else if (Game.state === 'RESULT' || Game.state === 'BONUS_VIDEO') {
        Game.toTitle();
    } else {
        // HOWTOãªã©ã¯é–‰ã˜ã‚‹
        Game.hideHowTo();
    }
}

// ===== å…¨ç”»é¢ï¼ˆè¿½åŠ ï¼‰ =====
async function toggleFullscreen() {
    const wrapper = document.getElementById('game-wrapper');
    const btn = document.getElementById('fullscreen-switch');

    // Fullscreen APIãŒã‚ã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆAndroid Chrome / PC ç­‰ï¼‰
    const canFS = wrapper && (wrapper.requestFullscreen || wrapper.webkitRequestFullscreen);
    const isFS = document.fullscreenElement || document.webkitFullscreenElement;

    try {
        if (canFS) {
            if (!isFS) {
                if (wrapper.requestFullscreen) await wrapper.requestFullscreen({ navigationUI: "hide" });
                else await wrapper.webkitRequestFullscreen();
                if (btn) btn.textContent = "â¤¢";
            } else {
                if (document.exitFullscreen) await document.exitFullscreen();
                else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
                if (btn) btn.textContent = "â›¶";
            }
            setTimeout(resizeGame, 50);
            return;
        }

        // iPhone Safari ã¯ requestFullscreen ãŒåŸºæœ¬ä½¿ãˆãªã„ã®ã§ã€ä»£æ›¿ã¨ã—ã¦ã€Œã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼éš ã—ã€ã‚’è©¦ã™
        window.scrollTo(0, 1);
        setTimeout(() => window.scrollTo(0, 1), 50);

        alert("iPhone Safariã¯ãƒœã‚¿ãƒ³ã§å®Œå…¨ãªå…¨ç”»é¢åŒ–ãŒé›£ã—ã„ã§ã™ã€‚\nã€å…±æœ‰ â†’ ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ã§èµ·å‹•ã™ã‚‹ã¨ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼ç„¡ã—ã§éŠã¹ã¾ã™ã€‚");
    } catch (e) {
        console.log(e);
        alert("å…¨ç”»é¢ã«ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚iPhoneã¯ã€ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ãŒç¢ºå®Ÿã§ã™ã€‚");
    }
}

window.onload = () => {
    // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆç”Ÿæˆ
    const palette = document.getElementById('color-palette');
    PALETTE_COLORS.forEach(c => {
        const btn = document.createElement('div');
        btn.className = 'color-btn';
        btn.id = `btn-${c}`;
        btn.style.backgroundColor = c;
        btn.onclick = () => Customizer.setColor(c);
        palette.appendChild(btn);
    });
    const secretBtn = document.createElement('div');
    secretBtn.className = 'color-btn secret';
    secretBtn.id = 'btn-secret';
    secretBtn.onclick = () => Customizer.setColor(null, true);
    palette.appendChild(secretBtn);

    Customizer.setColor(PALETTE_COLORS[0]);

    window.Game = Game;
    window.Customizer = Customizer;

    Game.toCustomize = () => Game.changeState('CUSTOMIZE');
    Game.toModeSelect = () => Game.changeState('MODE');
    Game.startGame = (mode) => Game.startRace(mode);
    Game.toTitle = () => { Game.changeState('TITLE'); Game.race = null; };
    Game.toResult = () => Game.changeState('RESULT');
    Game.showHowTo = () => {
        document.getElementById('screen-howto').classList.remove('hidden');
        Game.state = 'HOWTO';
        updateBackButton();
    };
    Game.hideHowTo = () => {
        document.getElementById('screen-howto').classList.add('hidden');
        Game.changeState('TITLE');
    };

    // æˆ»ã‚‹ãƒœã‚¿ãƒ³
    document.getElementById('btn-back').addEventListener('click', (e) => {
        e.stopPropagation();
        handleBack();
    });

    // å…¨ç”»é¢ãƒœã‚¿ãƒ³
    document.getElementById('fullscreen-switch').addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFullscreen();
    });

    // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³çŠ¶æ…‹å¤‰åŒ–ã§ãƒœã‚¿ãƒ³è¡¨ç¤ºã‚’åŒæœŸ
    document.addEventListener('fullscreenchange', () => {
        const btn = document.getElementById('fullscreen-switch');
        const isFS = !!document.fullscreenElement;
        if (btn) btn.textContent = isFS ? "â¤¢" : "â›¶";
        setTimeout(resizeGame, 50);
    });
    document.addEventListener('webkitfullscreenchange', () => {
        const btn = document.getElementById('fullscreen-switch');
        const isFS = !!document.webkitFullscreenElement;
        if (btn) btn.textContent = isFS ? "â¤¢" : "â›¶";
        setTimeout(resizeGame, 50);
    });

    // åˆæœŸã®æˆ»ã‚‹ãƒœã‚¿ãƒ³çŠ¶æ…‹
    updateBackButton();
};
</script>
</body>
</html>
